/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package project.myproject.aifirstproject;

import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ImageIcon;
import javax.swing.*;

/**
 *
 * @author Lenovo
 */
public class HillClimbingFrame extends javax.swing.JFrame {

    /**
     * Creates new form HillClimbingFrame
     */
    int n;              //N-Queen size
    int iterations=0;   
    int nextCounter=0;  //Counter for Next button
    int pathCounter=0;  //Counter for Path button
    int finalH=0;
    int numSuccessor=0;
    boolean solveUsedFlag=false;
    boolean [][]queenMatrix; //matrix used initially when randomize is clicked
    boolean [][]finalAnswer; //matrix of best solution
    ArrayList<MatrixWithHeuristic>  allSuccessors;    //all successors in the solving process
    ArrayList<MatrixWithHeuristic>  pathSuccessors;   //successors which are in the solution path
    private JLabel[][] matrixLabels; //labels to be added to the panel
    public HillClimbingFrame() {
        initComponents();
        createMatrixLabels();
        finalAnswer=new boolean[n][n];
        allSuccessors=new ArrayList<MatrixWithHeuristic>();
        pathSuccessors=new ArrayList<MatrixWithHeuristic>();
    }
    
    public HillClimbingFrame(int size) {
        this.n=size; //take size of the board from the Caller class (MainFrame)
        initComponents(); //Gui Initialization
        createMatrixLabels();
        finalAnswer=new boolean[n][n];
        allSuccessors=new ArrayList<MatrixWithHeuristic>();
        pathSuccessors=new ArrayList<MatrixWithHeuristic>();
        queenMatrix=new boolean[n][n];
        panelnxn.setVisible(true);
    }
    private void createMatrixLabels() {
        int rows = n;
        int cols = n;
        matrixLabels=new JLabel[rows][cols];
        // Create JLabel objects and add them to the matrixPanel
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                JLabel l=new JLabel("", SwingConstants.CENTER);
                l.setName("0"); //0 means it's an empty spot
                                    //1 means it has a queen
                //GUI desgin configuration for the labels.                    
                matrixLabels[i][j] = l;
                matrixLabels[i][j].setFont(new Font("Arial", Font.PLAIN, 20));
                matrixLabels[i][j].setOpaque(true);
                matrixLabels[i][j].setBackground(Color.WHITE);
                matrixLabels[i][j].setForeground(Color.BLACK);
                //add the labels to the Panel
                panelnxn.add(matrixLabels[i][j]);
            }
        }
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        startPanel = new javax.swing.JPanel();
        Randomize = new javax.swing.JButton();
        gotoHillClimbingBTN = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        panelnxn = new javax.swing.JPanel();
        backLabel = new javax.swing.JLabel();
        outputLabel = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        next = new javax.swing.JButton();
        bestSolution = new javax.swing.JButton();
        PathBTN = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
        });

        startPanel.setBackground(new java.awt.Color(153, 204, 255));
        startPanel.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        Randomize.setBackground(new java.awt.Color(255, 218, 0));
        Randomize.setFont(new java.awt.Font("Britannic Bold", 0, 24)); // NOI18N
        Randomize.setText("Randomize");
        Randomize.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        Randomize.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RandomizeActionPerformed(evt);
            }
        });
        startPanel.add(Randomize, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 40, 170, 60));

        gotoHillClimbingBTN.setBackground(new java.awt.Color(255, 218, 0));
        gotoHillClimbingBTN.setFont(new java.awt.Font("Britannic Bold", 0, 24)); // NOI18N
        gotoHillClimbingBTN.setText("Solve");
        gotoHillClimbingBTN.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        gotoHillClimbingBTN.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                gotoHillClimbingBTNActionPerformed(evt);
            }
        });
        startPanel.add(gotoHillClimbingBTN, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 120, 170, 60));

        jLabel3.setBackground(new java.awt.Color(153, 204, 255));
        jLabel3.setFont(new java.awt.Font("Britannic Bold", 0, 32)); // NOI18N
        jLabel3.setText("N - Queen");
        jLabel3.setOpaque(true);
        startPanel.add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(320, 20, 170, 40));

        panelnxn.setLayout(new java.awt.GridLayout(n, n, 5, 5));
        startPanel.add(panelnxn, new org.netbeans.lib.awtextra.AbsoluteConstraints(240, 70, 460, 340));

        backLabel.setIcon(new ImageIcon("C:\\Users\\Lenovo\\Desktop\\E-Learning (Mira)\\aiFirstProject\\back.png"));
        backLabel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                backLabelMouseClicked(evt);
            }
        });
        startPanel.add(backLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(70, 440, 100, 40));

        outputLabel.setFont(new java.awt.Font("Britannic Bold", 0, 22)); // NOI18N
        outputLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        startPanel.add(outputLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(290, 420, 370, 60));
        startPanel.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(90, 460, 70, 30));

        next.setBackground(new java.awt.Color(255, 218, 0));
        next.setFont(new java.awt.Font("Britannic Bold", 0, 24)); // NOI18N
        next.setText("Next");
        next.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        next.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextActionPerformed(evt);
            }
        });
        startPanel.add(next, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 200, 170, 60));

        bestSolution.setBackground(new java.awt.Color(255, 218, 0));
        bestSolution.setFont(new java.awt.Font("Britannic Bold", 0, 24)); // NOI18N
        bestSolution.setText("Best Solution");
        bestSolution.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        bestSolution.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bestSolutionActionPerformed(evt);
            }
        });
        startPanel.add(bestSolution, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 360, 170, 60));

        PathBTN.setBackground(new java.awt.Color(255, 218, 0));
        PathBTN.setFont(new java.awt.Font("Britannic Bold", 0, 24)); // NOI18N
        PathBTN.setText("Path");
        PathBTN.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        PathBTN.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PathBTNActionPerformed(evt);
            }
        });
        startPanel.add(PathBTN, new org.netbeans.lib.awtextra.AbsoluteConstraints(40, 280, 170, 60));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 772, Short.MAX_VALUE)
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                    .addGap(0, 6, Short.MAX_VALUE)
                    .addComponent(startPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 766, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 520, Short.MAX_VALUE)
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(startPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 520, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
        // TODO add your handling code here:
        //Open Window of Frame in the middle of the screen
        setLocationRelativeTo(null);
    }//GEN-LAST:event_formWindowOpened

    private void RandomizeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RandomizeActionPerformed
        // TODO add your handling code here:
        //Empty out the label
        outputLabel.setText("");
        //Set all counters to 0 and clear ArrayLists
        nextCounter=0;
        pathCounter=0;
        iterations=0;
        allSuccessors.clear();
        pathSuccessors.clear();
        //If a new State is created using the randomize button
        //Then set the solveUsedFlag to Zero because Solve has not been clicked yet
        solveUsedFlag=false;
        Random rand = new Random();
        //Array of Random positions from 0 to (n-1) 
        /*   0 0 Q 0
             Q 0 0 Q
             0 0 0 0
             0 Q 0 0
             the values in randomPosition will be
            {1,3,0,1}
        */
        int []randomPosition=new int[n];
        initEmpty(); //call initEmpty() to empty all the labels in the panel
        for(int i=0;i<n;i++)
        {
            randomPosition[i]=rand.nextInt(n);
            matrixLabels[randomPosition[i]][i].setName("1");
            matrixLabels[randomPosition[i]][i].setIcon(new ImageIcon("C:\\Users\\Lenovo\\Desktop\\E-Learning (Mira)\\aiFirstProject\\queen.png"));
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                //if label has Name=1 then put true on queenMatrix, otherwise put false
                /*
                false false true  false
                true  false false true
                false false false false
                false true  false false
                */
                queenMatrix[i][j]= matrixLabels[i][j].getName().equals("1") ? true : false;
            }
        }
        //put the Heuristic for the random board in the label
        outputLabel.setText("Randomized State H="+calculateHeuristic(queenMatrix));
        outputLabel.setBackground(new Color(255, 218, 0));
        outputLabel.setOpaque(true);
        outputLabel.setForeground(new Color(0,0,0));
        
    }//GEN-LAST:event_RandomizeActionPerformed

    private void gotoHillClimbingBTNActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_gotoHillClimbingBTNActionPerformed
        // TODO add your handling code here:
        solveUsedFlag=true;
        boolean [][]chosenSuccessor=new boolean[n][n];
        boolean [][]currentState=new boolean[n][n];
        //Copy one matrix to another
        for (int v = 0; v < n; v++) 
                System.arraycopy(queenMatrix[v], 0, currentState[v], 0, n);
        
        int currentH = calculateHeuristic(currentState) ; //hold the currentHeursitic value
        while (currentH != 0) 
        {
            int chosenH = hillClimbing(currentState, chosenSuccessor);
            if (chosenH >= currentH) 
            {
                break; // Exit the loop if no solution is found
            } 
            else 
            {
                currentH = chosenH; //new Successor has a a Heuristic value lower than current State
                //make currentState=chosenSuccessor since currentH>chosenH
                for (int v = 0; v < n; v++) 
                {
                    System.arraycopy(chosenSuccessor[v], 0, currentState[v], 0, n);
                }
                printMatrix(currentState);
            }
        }
        

        
    }//GEN-LAST:event_gotoHillClimbingBTNActionPerformed
    public int hillClimbing(boolean [][]currentState,boolean [][]chosenSuccessor)
    {
        //tempQueenMatrix is used to create all different 
        //possibilites of successors for the current state
        boolean [][]tempQueenMatrix=new boolean[n][n];
        int []queenPositions=new int[n];
        //Array of Queen positions from 0 to (n-1) 
        /*   0 0 Q 0
             Q 0 0 Q
             0 0 0 0
             0 Q 0 0
             the values of where each queen in a row is in every column in queenPositions for this example will be
            {1,3,0,1}
        */
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(currentState[i][j])
                    queenPositions[j]=i;
            }
        }
        int counter=0;
        int tempH=0;
        int currentH=calculateHeuristic(currentState);
        System.out.println("H ="+currentH);
        
        //k represnts each column
        for(int k=0;k<n;k++)
        {
            //copy currentState to tempQueenMatrix
            for (int v = 0; v < n; v++) 
                System.arraycopy(currentState[v], 0, tempQueenMatrix[v], 0, n);
            
            tempQueenMatrix[queenPositions[k]][k]=false;
            for(int otherPos=0;otherPos<n;otherPos++)
            {
                //otherPos=queenPositions[k] that means it's the original State and it's not a successor so don't do anything
                if(otherPos!=queenPositions[k])
                {
                    tempQueenMatrix[otherPos][k]=true;
                    System.out.println("Successor "+(++counter));//print Successor #
                    printMatrix(tempQueenMatrix);
                    tempH=calculateHeuristic(tempQueenMatrix);
                    iterations++;
                    //Create a new object of MatrixWithHeuristic to add it to the
                    // allSuccessors list
                    MatrixWithHeuristic q=new MatrixWithHeuristic(n,tempQueenMatrix,"Successor #"+iterations+" H="+tempH);
                    allSuccessors.add(q);
                    System.out.println("Successor #"+counter+" = "+tempH+"\n\n");//print Successor H=
                    if(tempH<currentH)
                    {
                        currentH=tempH;
                        MatrixWithHeuristic q1=new MatrixWithHeuristic(n,tempQueenMatrix,"Successor #"+iterations+" H="+tempH);
                        //add it to the path, this successor will be used to achieve the best solution
                        pathSuccessors.add(q1);
                        numSuccessor=iterations;
                        //copy the tempQueenMatrix to the chosenSuccessor matrix, up until now this is the best Successor
                        for (int v = 0; v < n; v++) 
                            System.arraycopy(tempQueenMatrix[v], 0, chosenSuccessor[v], 0, n);
                    }
                    //Set it back to 0 to move on to next Successor
                    tempQueenMatrix[otherPos][k] = false;
                     
                }
            }

        }
        //copy the chosenSuccessor to the finalAnswer to use it later for the best Solution button
        for (int v = 0; v < n; v++) 
                System.arraycopy(chosenSuccessor[v], 0, finalAnswer[v], 0, n);
        //save final hesuristic
        finalH=currentH;
        System.out.println("Winning Successor #: "+numSuccessor+" H="+currentH);
        printMatrix(chosenSuccessor);
        return currentH;
    }
    public static void printMatrix(boolean[][] matrix) {
        for (boolean[] row : matrix) 
        {
            //1 represents Queen and 0 represents empty cell
            for (boolean value : row) 
            {
                System.out.print((value ? "1" : "0") + " ");
            }
            System.out.println();
        }
        System.out.println();
    }
    private int calculateHeuristic(boolean[][] currentState) 
    {
        int attackingPairs = 0;
            for (int row = 0; row < n; row++) 
            {
                for (int col = 0; col < n; col++) 
                {
                    if (currentState[row][col]) 
                    {
                        // Check for conflicts in the same row
                        for (int c = col + 1; c < n; c++) 
                        {
                            if (currentState[row][c]) 
                            {
                                attackingPairs++;
                            }
                        }
                        // Check for conflicts in the diagonal (right-up)
                        //r >= 0 && c < n is to maintain we stay in the matrix correct borders
                        for (int r = row - 1, c = col + 1; r >= 0 && c < n; r--, c++) 
                        {
                            if (currentState[r][c]) 
                            {
                                attackingPairs++;
                            }
                        }
                        // Check for conflicts in the diagonal (right-down)
                        //r < n && c < n is to maintain we stay in the matrix correct borders
                        for (int r = row + 1, c = col + 1; r < n && c < n; r++, c++) 
                        {
                            if (currentState[r][c]) 
                            {
                                attackingPairs++;
                            }
                        }
                    }
                }
            }
    return attackingPairs ;
}
    private void backLabelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_backLabelMouseClicked
        // TODO add your handling code here:
        this.toBack();
        MainFrame MF=new MainFrame();
        MF.setVisible(true);
        MF.toFront();
        this.dispose();
    }//GEN-LAST:event_backLabelMouseClicked

    private void nextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextActionPerformed
        // TODO add your handling code here:
        if(solveUsedFlag&&nextCounter<allSuccessors.size())
        {
            //Show All successors and their H value
            updatePanel(allSuccessors.get(nextCounter).getMatrix());
            outputLabel.setText(allSuccessors.get(nextCounter).getStr());
            nextCounter++;
        }
        else if(nextCounter>=allSuccessors.size())
        {
            //When we're done showing all the successors, show the best solution at the end
            updatePanel(finalAnswer);
            outputLabel.setText("Best Solution is Successor#"+ numSuccessor+" H="+finalH);
        }
    }//GEN-LAST:event_nextActionPerformed

    private void bestSolutionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bestSolutionActionPerformed
        // TODO add your handling code here:
        if(solveUsedFlag)
        {
            //Show best solution and their H value
            updatePanel(finalAnswer);
            outputLabel.setText("Best Solution is Successor#"+ numSuccessor+" H="+finalH);
        }
    }//GEN-LAST:event_bestSolutionActionPerformed

    private void PathBTNActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PathBTNActionPerformed
        // TODO add your handling code here:
        if(solveUsedFlag&&pathCounter<pathSuccessors.size())
        {
            //Show successors involved in the path and their H values
            updatePanel(pathSuccessors.get(pathCounter).getMatrix());
            outputLabel.setText(pathSuccessors.get(pathCounter).getStr());
            pathCounter++;
        }
    }//GEN-LAST:event_PathBTNActionPerformed
    void initEmpty()
    {
        //Empty the panel 
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                matrixLabels[i][j].setName("0");
                matrixLabels[i][j].setIcon(null);
            }
        }
    }
    
    void updatePanel(boolean [][]currentState)
    {
        initEmpty();
        //it shows queen for true and nothing for false depending on the values in currentState
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                matrixLabels[i][j].setIcon(currentState[i][j]?new ImageIcon("C:\\Users\\Lenovo\\Desktop\\E-Learning (Mira)\\aiFirstProject\\queen.png"):null);
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(HillClimbingFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(HillClimbingFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(HillClimbingFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(HillClimbingFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new HillClimbingFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton PathBTN;
    private javax.swing.JButton Randomize;
    private javax.swing.JLabel backLabel;
    private javax.swing.JButton bestSolution;
    private javax.swing.JButton gotoHillClimbingBTN;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JButton next;
    private javax.swing.JLabel outputLabel;
    private javax.swing.JPanel panelnxn;
    private javax.swing.JPanel startPanel;
    // End of variables declaration//GEN-END:variables
}
